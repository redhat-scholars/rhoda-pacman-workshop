= Background
:navtitle: A brief walk-through
[#storage]
== Background: Storage
Most useful applications are "stateful" or "dynamic" in some way, and this is
usually achieved with a database or other data storage. In this lab we are
going to add MongoDB to our `pacman` application and then rewire it to
talk to the database using environment variables via a secret.

We are going to use the MongoDB image that is included with OpenShift.

By default, this will use *EmptyDir* for data storage, which means if the *Pod*
disappears the data does as well. In a real application you would use
OpenShift's persistent storage mechanism to attach real-world storage (NFS,
Ceph, EBS, iSCSI, etc) to the *Pods* to give them a persistent place to store their
data.

[#challenges_dbaas]
== Background: DBaaS & Present Challenges

image::challenge.png[DBaaS & Present Challenges,800,align="center"]


[#sol_rh_dbaas]
== Background: Red Hat Solution

More efficient connection, DB utilization
Faster and easier self-service for developers
Centralized monitoring, consistent control plane for admins

image::solution.png[Red Hat Solution,800,align="center"]

[#bg_sb_lib]
== Background: Service binding libraries
The Kubernetes service binding feature was introduced to bring consistency to the way secrets are shared for connecting applications to external services, such as REST APIs, databases, and many other services.
OpenShift Database Access leverages the service binding feature to bring a low-touch administrative experience to provisioning, and managing access to external database services.
The service binding feature enables developers to connect their applications to database services with a consistent, and predictable experience.
Specifically, a service binding creates a volume on the application pod, and organizes the information to make a connection to the database in a directory structure.
The volume mount point is exposed as an environment variable.
Developer frameworks, such as Quarkus, are service binding aware, and can automatically connect to a database using this exposed workload information without needing to embed database connection information in the application source code.

Here are some application examples on how to use a service binding library:

* link:https://github.com/RHEcosystemAppEng/mongo-quickstart[Mongo Quarkus application]
* link:https://github.com/RHEcosystemAppEng/postgresql-orm-quickstart[Crunchy Postgres Quarkus application]
* link:https://github.com/myeung18/postgresql-orm-demo-app[CockroachDB Postgres Quarkus application]
* link:https://github.com/myeung18/cockroachdb-go-quickstart[CockroachDB Postgres Go application]
* link:https://github.com/RHODA-lab/rhoda-qa-python/blob/main/run-test.py[Crunchy Postgres Python test program]
* link:https://github.com/RHODA-lab/rhoda-qa-python/blob/main/test-cockroachdb.py[CockroachDB Postgres Python test program]

[role="_additional-resources"]
.Additional resources

* See the link:https://github.com/servicebinding/spec#workload-projection[Kubernetes GitHub project] for more details on service bindings.
